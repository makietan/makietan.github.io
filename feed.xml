<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ja"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://makietan.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://makietan.github.io/" rel="alternate" type="text/html" hreflang="ja" /><updated>2026-01-25T18:29:00+09:00</updated><id>https://makietan.github.io/feed.xml</id><title type="html">肉とお米とブロッコリー</title><subtitle>ここは日報をメインに書きます.</subtitle><author><name>makietan</name></author><entry><title type="html">松のやの害悪客について考える</title><link href="https://makietan.github.io/human/2026/01/25/report.html" rel="alternate" type="text/html" title="松のやの害悪客について考える" /><published>2026-01-25T00:00:00+09:00</published><updated>2026-01-25T00:00:00+09:00</updated><id>https://makietan.github.io/human/2026/01/25/report</id><content type="html" xml:base="https://makietan.github.io/human/2026/01/25/report.html"><![CDATA[<p>今日、松のやで非常に不快な思いをした。ある一人の老害客の振る舞いが原因だ。</p>

<p>まず、食事の提供口でのこと。その人物は、まさにこれから他人に渡されるであろう食事の前で、マスクもせずに大声で喋り始めた。飛沫が飲食物にかかるのではないかと、衛生的に極めて不快だった。それだけではない。提供口を塞ぐように立ち尽くし、私が自分の番号を呼ばれても、商品を受け取ることができない。余計な憤怒と不快感が募るばかりだった。</p>

<p>ようやく食事を受け取り、自席へ向かおうとすると、またしてもその老害が通路を塞いでいた。今度は他人の席の前で、何をするでもなくスマートフォンをいじりながら立ち止まっている。近くに立たれる圧迫感、進路を妨害される煩わしさ、そして先程の衛生面への懸念が再び頭をよぎる。これが混雑時ならまだしも、むしろ空いている店内での出来事だったため、その無神経さに対する殺意にも似た怒りが込み上げてきた。</p>

<p>こちらはただ、注文した食事を受け取り、静かに席について食べたいだけなのだ。なぜ、このような些細な願いすら、他人の無神経な行動によって妨げられなければならないのか。</p>

<p>もちろん、第一に責められるべきは、この害悪客の常識を欠いた行動であることは間違いない。しかし、こうした迷惑行為を容易に許してしまう店のシステムにも、改善の余地があるのではないだろうか。例えば、提供口の構造や客の動線を見直すことで、今回のようなトラブルは避けられたかもしれない。個人のマナーに期待するだけでは、限界がある。</p>]]></content><author><name>makietan</name></author><category term="human" /><summary type="html"><![CDATA[今日、松のやで非常に不快な思いをした。ある一人の老害客の振る舞いが原因だ。]]></summary></entry><entry><title type="html">小林さんちのメイドラゴンのフィルムコンサートに行ってきた</title><link href="https://makietan.github.io/otaku/2026/01/24/report2.html" rel="alternate" type="text/html" title="小林さんちのメイドラゴンのフィルムコンサートに行ってきた" /><published>2026-01-24T22:29:37+09:00</published><updated>2026-01-24T22:29:37+09:00</updated><id>https://makietan.github.io/otaku/2026/01/24/report2</id><content type="html" xml:base="https://makietan.github.io/otaku/2026/01/24/report2.html"><![CDATA[<p>越谷サンシティホールで開催された「小林さんちのメイドラゴン」のフィルムコンサートに行ってきた。
フィルムコンサートとは、映像に合わせてオーケストラが生演奏を行うイベントで、
今回はメイドラゴン1期、2期、劇場版を1日で楽しめるという贅沢な内容だった。</p>

<p>昼の会場はほぼ満席で、夜の会場はちらほら空席がある程度。
オーケストラの生演奏は迫力があり、映像と音楽が一体となって作品の世界観をより深く味わうことができた。
特にコントラバスの低音が振動として伝わってきて、身体全体で音楽を感じることができたのが印象的だった。
また、普段はあまり注目しない音楽の細部にも気づくことができ、新たな発見があった。
トライアングルやタンバリン、ビブラスラップみたいな打楽器の音が意外と多用されていた。</p>

<p>メイドラゴンのキャラクターたちが織りなす日常の中に、音楽がどのように溶け込んでいるのかを改めて感じることができた。
今回のフィルムコンサートは、メイドラゴンの魅力を再確認する素晴らしい機会となった。
オーケストラの生演奏と映像の融合は、作品の世界観をより豊かにし、ファンにとって忘れられない体験となった。
またこういうイベントがあればぜひ参加したいと思う。</p>]]></content><author><name>makietan</name></author><category term="otaku" /><summary type="html"><![CDATA[越谷サンシティホールで開催された「小林さんちのメイドラゴン」のフィルムコンサートに行ってきた。 フィルムコンサートとは、映像に合わせてオーケストラが生演奏を行うイベントで、 今回はメイドラゴン1期、2期、劇場版を1日で楽しめるという贅沢な内容だった。]]></summary></entry><entry><title type="html">「逆襲」と名のつくアニメ作品は名言がある説</title><link href="https://makietan.github.io/otaku/2026/01/24/report.html" rel="alternate" type="text/html" title="「逆襲」と名のつくアニメ作品は名言がある説" /><published>2026-01-24T00:00:00+09:00</published><updated>2026-01-24T00:00:00+09:00</updated><id>https://makietan.github.io/otaku/2026/01/24/report</id><content type="html" xml:base="https://makietan.github.io/otaku/2026/01/24/report.html"><![CDATA[<h2 id="ミュウツーの逆襲">ミュウツーの逆襲</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>わたしは誰だ…
ここはどこだ……
誰が生めと頼んだ!
誰が造ってくれと願った…!!
わたしはわたしを生んだ全てを恨む…!
だからこれは…　攻撃でもなく　宣戦布告でもなく
わたしを生み出したお前達への
"逆襲"　だ
</code></pre></div></div>

<h2 id="機動戦士ガンダム-逆襲のシャア">機動戦士ガンダム 逆襲のシャア</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ふざけるな！たかが石ころ1つ、ガンダムで押し出してやる！
バカなことはやめろ！
やってみなければ分からん！
正気か！？
様ほど急ぎすぎもしなければ、人類に絶望もしちゃいない！
アクシズの落下は始まっているんだぞ！
νガンダムは伊達じゃない！！
</code></pre></div></div>

<p>「それいけ!アンパンマン ゴミラの星」があまりにも酷似しているシーンでもある。</p>

<h2 id="おわりに">おわりに</h2>

<p>2つしか出てこないけど、まぁそれだけインパクトが強いということで。</p>

<ul>
  <li>劇場版 探偵オペラ ミルキィホームズ ～逆襲のミルキィホームズ</li>
  <li>ちびゴジラの逆襲</li>
  <li>ハコヅメ〜交番女子の逆襲〜</li>
  <li>タイムボカン 逆襲の三悪人</li>
  <li>ガンダムビルドファイターズ GMの逆襲</li>
  <li>クレヨンしんちゃん ガチンコ!逆襲のロボとーちゃん</li>
  <li>クレヨンしんちゃん 嵐を呼ぶ モーレツ!オトナ帝国の逆襲</li>
  <li>デジモンアドベンチャー０２　ディアボロモンの逆襲</li>
  <li>それいけ！アンパンマン ばいきんまんの逆襲</li>
  <li>マシンロボ クロノスの大逆襲</li>
</ul>

<p>とかもあるけど名言は特にないかなと。</p>

<p>名作はあるんだけどな。</p>

<p>ゴジラとかスター・ウォーズとかはアニメじゃないんで除外しました。</p>

<p>Wikipediaの「逆襲」を含む作品一覧も参考にしました。</p>

<p>13,350 件もあるんですね……。</p>

<p><code class="language-plaintext highlighter-rouge">https://ja.wikipedia.org/w/index.php?limit=500&amp;offset=20&amp;profile=default&amp;search=%E9%80%86%E8%A5%B2&amp;title=%E7%89%B9%E5%88%A5:%E6%A4%9C%E7%B4%A2&amp;ns0=1</code></p>]]></content><author><name>makietan</name></author><category term="otaku" /><summary type="html"><![CDATA[ミュウツーの逆襲]]></summary></entry><entry><title type="html">今更ながら Swift Package Manager を試す</title><link href="https://makietan.github.io/tech/2026/01/20/report.html" rel="alternate" type="text/html" title="今更ながら Swift Package Manager を試す" /><published>2026-01-20T00:00:00+09:00</published><updated>2026-01-20T00:00:00+09:00</updated><id>https://makietan.github.io/tech/2026/01/20/report</id><content type="html" xml:base="https://makietan.github.io/tech/2026/01/20/report.html"><![CDATA[<p>まずは Swift Package Manager (SPM) の基本的な使い方を試してみることにした。以下のコマンドで新しいパッケージを作成する。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swift package init <span class="nt">--type</span> library
</code></pre></div></div>

<p>とりあえずライブラリタイプで初期化し、生成された <code class="language-plaintext highlighter-rouge">Package.swift</code> ファイルを確認する。</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// swift-tools-version:6.2</span>
<span class="kd">import</span> <span class="kt">PackageDescription</span>
<span class="k">let</span> <span class="nv">package</span> <span class="o">=</span> <span class="kt">Package</span><span class="p">(</span>
    <span class="nv">name</span><span class="p">:</span> <span class="s">"MyLibrary"</span><span class="p">,</span>
    <span class="nv">products</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">library</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="s">"MyLibrary"</span><span class="p">,</span>
            <span class="nv">targets</span><span class="p">:</span> <span class="p">[</span><span class="s">"MyLibrary"</span><span class="p">]),</span>
    <span class="p">],</span>
    <span class="nv">targets</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">target</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="s">"MyLibrary"</span>
        <span class="p">),</span>
        <span class="o">.</span><span class="nf">testTarget</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="s">"MyLibraryTests"</span><span class="p">,</span>
            <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="s">"MyLibrary"</span><span class="p">]),</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre></div></div>

<p>てな感じになる。</p>

<p>わりと簡単だ。</p>

<p>詳細書くほどではないのでとりあえずここまで。</p>

<p>今後、プロジェクトで使う機会があればまた掘り下げてみたい。</p>]]></content><author><name>makietan</name></author><category term="tech" /><summary type="html"><![CDATA[まずは Swift Package Manager (SPM) の基本的な使い方を試してみることにした。以下のコマンドで新しいパッケージを作成する。]]></summary></entry><entry><title type="html">立ってたらいい感じに勃起するけど騎乗位になると衰えを感じる</title><link href="https://makietan.github.io/health/2026/01/19/report.html" rel="alternate" type="text/html" title="立ってたらいい感じに勃起するけど騎乗位になると衰えを感じる" /><published>2026-01-19T00:00:00+09:00</published><updated>2026-01-19T00:00:00+09:00</updated><id>https://makietan.github.io/health/2026/01/19/report</id><content type="html" xml:base="https://makietan.github.io/health/2026/01/19/report.html"><![CDATA[<p>健康には気をつけましょう。
血流の問題かもしれません。
立ってたらいい感じに勃起するけど騎乗位になると衰えを感じる。
健康的な生活習慣を維持することで、全体的なパフォーマンスが向上させたい。</p>]]></content><author><name>makietan</name></author><category term="health" /><summary type="html"><![CDATA[健康には気をつけましょう。 血流の問題かもしれません。 立ってたらいい感じに勃起するけど騎乗位になると衰えを感じる。 健康的な生活習慣を維持することで、全体的なパフォーマンスが向上させたい。]]></summary></entry><entry><title type="html">git の submodule のユーザー設定は .git/modules に保存される</title><link href="https://makietan.github.io/tech/2026/01/14/report.html" rel="alternate" type="text/html" title="git の submodule のユーザー設定は .git/modules に保存される" /><published>2026-01-14T00:00:00+09:00</published><updated>2026-01-14T00:00:00+09:00</updated><id>https://makietan.github.io/tech/2026/01/14/report</id><content type="html" xml:base="https://makietan.github.io/tech/2026/01/14/report.html"><![CDATA[<p>どうやらグローバルがデフォルトで使用されているようだ。
変更したい場合は <code class="language-plaintext highlighter-rouge">.git/modules/&lt;submodule_name&gt;/config</code> に設定を追加すればよい。</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[user]</span>
    <span class="py">name</span> <span class="p">=</span> <span class="s">Your Name</span>
    <span class="py">email</span> <span class="p">=</span> <span class="s">your.email@users.noreply.github.com</span>
</code></pre></div></div>

<p>サブモジュールがあるディレクトリの <code class="language-plaintext highlighter-rouge">.git</code> には <code class="language-plaintext highlighter-rouge">gitdir: ../.git/modules/&lt;submodule_name&gt;</code> のように書かれている。
これを辿って追記してくれるスクリプトを書くのもいいかもしれない。</p>]]></content><author><name>makietan</name></author><category term="tech" /><summary type="html"><![CDATA[どうやらグローバルがデフォルトで使用されているようだ。 変更したい場合は .git/modules/&lt;submodule_name&gt;/config に設定を追加すればよい。]]></summary></entry><entry><title type="html">Apple サポートに連絡する方法</title><link href="https://makietan.github.io/tech/2026/01/13/report.html" rel="alternate" type="text/html" title="Apple サポートに連絡する方法" /><published>2026-01-13T00:00:00+09:00</published><updated>2026-01-13T00:00:00+09:00</updated><id>https://makietan.github.io/tech/2026/01/13/report</id><content type="html" xml:base="https://makietan.github.io/tech/2026/01/13/report.html"><![CDATA[<div class="card">
  <a href="https://getsupport.apple.com/?locale=ja_JP"></a>
  <div class="card__header">
    <a href="https://getsupport.apple.com/?locale=ja_JP">getsupport.apple.com</a>
  </div>
  <div class="card__image">
    <img src="" />
  </div>
  <div class="card__title">
    <p>お問い合わせ</p>
  </div>
  <div class="card__description">
    <p>Appleサポートが問題解決のお手伝いをします。</p>
  </div>
</div>

<p>とりあえずここから自分の端末を選んでいけば、サポートに連絡する方法がわかる。</p>

<div class="card">
  <a href="https://getsupport.apple.com/products"></a>
  <div class="card__header">
    <a href="https://getsupport.apple.com/products">getsupport.apple.com</a>
  </div>
  <div class="card__image">
    <img src="" />
  </div>
  <div class="card__title">
    <p>お問い合わせ</p>
  </div>
  <div class="card__description">
    <p>サポートが必要な製品やサービスを選択してください</p>
  </div>
</div>

<p>こっちもある。</p>]]></content><author><name>makietan</name></author><category term="tech" /><summary type="html"><![CDATA[getsupport.apple.com お問い合わせ Appleサポートが問題解決のお手伝いをします。]]></summary></entry><entry><title type="html">iPhone をアップデートしたらエラー 100 が発生しておそらく文鎮化した</title><link href="https://makietan.github.io/tech/2026/01/07/report.html" rel="alternate" type="text/html" title="iPhone をアップデートしたらエラー 100 が発生しておそらく文鎮化した" /><published>2026-01-07T00:00:00+09:00</published><updated>2026-01-07T00:00:00+09:00</updated><id>https://makietan.github.io/tech/2026/01/07/report</id><content type="html" xml:base="https://makietan.github.io/tech/2026/01/07/report.html"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iPhone “iPhone”をアップデートできませんでした。不明なエラーが発生しました（100）。 06A6.0064
</code></pre></div></div>

<p>最悪すぎる…。</p>

<p>とりあえず Apple の店に行く。</p>

<p>はぁ…。</p>

<p>最悪。</p>

<p>Apple はクソ。</p>]]></content><author><name>makietan</name></author><category term="tech" /><summary type="html"><![CDATA[iPhone “iPhone”をアップデートできませんでした。不明なエラーが発生しました（100）。 06A6.0064]]></summary></entry><entry><title type="html">Intel Mac (macOS 13) に yt-dlp を GitHub ソースからインストールする方法</title><link href="https://makietan.github.io/tech/2025/12/27/report.html" rel="alternate" type="text/html" title="Intel Mac (macOS 13) に yt-dlp を GitHub ソースからインストールする方法" /><published>2025-12-27T00:00:00+09:00</published><updated>2025-12-27T00:00:00+09:00</updated><id>https://makietan.github.io/tech/2025/12/27/report</id><content type="html" xml:base="https://makietan.github.io/tech/2025/12/27/report.html"><![CDATA[<p>macOS 13(Ventura)などのIntel Mac環境で、Homebrewを使わずにGitHubのリポジトリから<code class="language-plaintext highlighter-rouge">yt-dlp</code>をインストールする手順をまとめます。</p>

<p>Pythonの<code class="language-plaintext highlighter-rouge">error: externally-managed-environment</code>(PEP 668)を回避するため、仮想環境(venv)を作成します。シンボリックリンクでシステム全体から呼び出せるように設定します。</p>

<hr />

<h2 id="1-ソースコードの取得">1. ソースコードの取得</h2>
<p>まず、適当な作業ディレクトリに移動し、GitHubから最新のリポジトリをクローンします。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/project/
git clone https://github.com/yt-dlp/yt-dlp.git
<span class="nb">cd </span>yt-dlp
</code></pre></div></div>

<h2 id="2-仮想環境-venv-の作成とインストール">2. 仮想環境 (venv) の作成とインストール</h2>
<p>システム環境を保護するため、ディレクトリ内に隔離されたPython環境を作ります。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 仮想環境を作成</span>
python3 <span class="nt">-m</span> venv venv

<span class="c"># 仮想環境を有効化</span>
<span class="nb">source </span>venv/bin/activate

<span class="c"># 仮想環境内に yt-dlp をインストール</span>
python3 <span class="nt">-m</span> pip <span class="nb">install</span> <span class="nb">.</span>

<span class="c"># バージョンが表示されるか確認</span>
yt-dlp <span class="nt">--version</span>

<span class="c"># 確認できたら仮想環境を抜ける</span>
deactivate
</code></pre></div></div>

<h2 id="3-シンボリックリンクの設定">3. シンボリックリンクの設定</h2>
<p>自作のシェルスクリプトやターミナルから直接 <code class="language-plaintext highlighter-rouge">yt-dlp</code> コマンドを呼び出せるよう、パスの通った場所にリンクを作成します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># リンクを作成（パスは実際の環境に合わせて書き換えてください）</span>
<span class="nb">sudo ln</span> <span class="nt">-s</span> /Users/あなたのユーザー名/yt-dlp/venv/bin/yt-dlp /usr/local/bin/yt-dlp
</code></pre></div></div>

<h2 id="4-動作確認">4. 動作確認</h2>
<p>設定が完了したら、新しいターミナルを開いて以下のコマンドでパスを確認します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>which yt-dlp
<span class="c"># /usr/local/bin/yt-dlp と表示されれば完了</span>
</code></pre></div></div>

<hr />

<h2 id="補足アップデート方法">補足：アップデート方法</h2>

<p>最新のソースに更新したい場合は、ディレクトリに移動して <code class="language-plaintext highlighter-rouge">git pull</code> 後に再度インストールを行います。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~/project/yt-dlp
git pull
<span class="nb">source </span>venv/bin/activate
python3 <span class="nt">-m</span> pip <span class="nb">install</span> <span class="nb">.</span>
deactivate
</code></pre></div></div>

<h2 id="必須ffmpegについて">必須：FFmpegについて</h2>
<p>動画と音声を結合するには<strong>FFmpeg</strong>が必要です。Homebrewが使えない場合は、公式バイナリをダウンロードして<code class="language-plaintext highlighter-rouge">/usr/local/bin</code>へ配置してください。</p>]]></content><author><name>makietan</name></author><category term="tech" /><summary type="html"><![CDATA[macOS 13(Ventura)などのIntel Mac環境で、Homebrewを使わずにGitHubのリポジトリからyt-dlpをインストールする手順をまとめます。]]></summary></entry><entry><title type="html">平均値、中央値、最頻値、標準偏差を求めるプログラム</title><link href="https://makietan.github.io/tech/2025/12/23/report.html" rel="alternate" type="text/html" title="平均値、中央値、最頻値、標準偏差を求めるプログラム" /><published>2025-12-23T00:00:00+09:00</published><updated>2025-12-23T00:00:00+09:00</updated><id>https://makietan.github.io/tech/2025/12/23/report</id><content type="html" xml:base="https://makietan.github.io/tech/2025/12/23/report.html"><![CDATA[<h2 id="概要">概要</h2>
<p>このプログラムは、与えられた数値のリストから平均値、中央値、最頻値を計算します。数値は改行で区切られた形式で入力されます。</p>
<h2 id="使用方法">使用方法</h2>
<ol>
  <li>下のテキストエリアに数値を改行で区切って入力します。</li>
  <li>ページを読み込むと、平均値、中央値、最頻値が計算され、表示されます。
    <h2 id="テキストエリア">テキストエリア</h2>
  </li>
</ol>
<textarea rows="20" cols="80" id="list" oninput="run()"></textarea>
<h2 id="オプション">オプション</h2>
<div id="controls" style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:8px 0;">
    <label><input type="checkbox" id="opt-show-mean" checked="" /> 平均線を表示</label>
    <label><input type="checkbox" id="opt-show-median" checked="" /> 中央値線を表示</label>
    <label>小数桁: <input type="number" id="opt-decimals" value="2" min="0" max="6" style="width:60px" /></label>
    <button id="btn-copy" type="button">結果をコピー</button>
    <button id="btn-download-png" type="button">グラフを保存(PNG)</button>
    <label><input type="checkbox" id="opt-highlight-outliers" /> 外れ値をハイライト</label>
    <label>k(σ): <input type="number" id="opt-outlier-k" value="2" min="0" max="10" step="0.5" style="width:60px" /></label>
    <label><input type="checkbox" id="opt-show-labels" /> ラベル表示</label>
    <button id="btn-copy-numbers" type="button">数値をコピー</button>
    <button id="btn-copy-url" type="button">URLをコピー</button>
    <style>
        #controls button { padding: 4px 8px; }
        #controls label { user-select: none; }
    </style>
</div>
<h2 id="結果表示">結果表示</h2>
<div id="output"></div>
<p><br /></p>
<div id="output-graph"></div>
<script>
function run() {
    const list = document.getElementById("list").value.split("\n");
    // 元行テキストと数値の対応を保持
    const entries = [];
    for (const line of list) {
            const t = line.trim();
            if (t === "") continue;
            const cleaned = t.replace(/[^0-9.\-]/g, '');
            const n = Number(cleaned);
            if (!isNaN(n)) {
                    entries.push({ value: n, raw: t });
            }
    }
    const numbers = entries.map(e => e.value);
  if (numbers.length === 0) {
      document.getElementById("output").textContent = "有効な数値がありません。";
  } else {
      // 表示オプションとフォーマッタ
      const showMean = document.getElementById('opt-show-mean')?.checked ?? true;
      const showMedian = document.getElementById('opt-show-median')?.checked ?? true;
      const decimalsInput = document.getElementById('opt-decimals');
      const decimals = decimalsInput ? Math.max(0, Math.min(6, parseInt(decimalsInput.value) || 0)) : 2;
      const fmt = (v) => (Number.isFinite(v) ? Number(v).toFixed(decimals) : String(v));
      const highlightOutliers = document.getElementById('opt-highlight-outliers')?.checked ?? false;
      const outlierKInput = document.getElementById('opt-outlier-k');
      const outlierK = outlierKInput ? Math.max(0, Math.min(10, parseFloat(outlierKInput.value) || 0)) : 0;
      const showLabels = document.getElementById('opt-show-labels')?.checked ?? false;
      // 平均値の計算
      const sum = numbers.reduce((a, b) => a + b, 0);
      const mean = sum / numbers.length;
      // 中央値の計算
      const sorted = [...numbers].sort((a, b) => a - b);
      let median;
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
          median = (sorted[mid - 1] + sorted[mid]) / 2;
      } else {
          median = sorted[mid];
      }
      // 最頻値の計算
      const frequency = {};
      let maxFreq = 0;
      let mode;
      for (const num of numbers) {
          frequency[num] = (frequency[num] || 0) + 1;
          if (frequency[num] > maxFreq) {
              maxFreq = frequency[num];
              mode = num;
          }
      }
      // 分散の計算
      const variance = numbers.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / numbers.length;
      // 標準偏差の計算
      const stdDev = Math.sqrt(variance);
      // 最小値と最大値の計算
      const min = Math.min(...numbers);
      const max = Math.max(...numbers);
      // 範囲の計算
      const range = max - min;
      // 歪度の計算
      const skewness = numbers.reduce((a, b) => a + Math.pow((b - mean) / stdDev, 3), 0) / numbers.length;
      // 尖度の計算
      const kurtosis = numbers.reduce((a, b) => a + Math.pow((b - mean) / stdDev, 4), 0) / numbers.length - 3;
      // 結果の表示
      document.getElementById("output").innerText = [
          `平均値: ${fmt(mean)}`,
          `中央値: ${fmt(median)}`,
          `最頻値: ${fmt(mode)}`,
          `分散: ${fmt(variance)}`,
          `標準偏差: ${fmt(stdDev)}`,
          `最小値: ${fmt(min)}`,
          `最大値: ${fmt(max)}`,
          `範囲: ${fmt(range)}`,
          `歪度: ${fmt(skewness)}`,
          `尖度: ${fmt(kurtosis)}`
      ].join("\n");
      // ヒストグラム計算は不要になったため削除（散布図のみ描画）
      // numbers を使って 散布図を描画する（x=インデックス, y=値）
            const containerEl = document.getElementById("output-graph");
            const containerWidth = containerEl ? containerEl.clientWidth : 0;
            const width = Math.max(360, containerWidth || 600);
            const height = Math.round(width * 0.6);
            const margin = 50;
            let graphHtml = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="border:1px solid black;width:100%;height:auto">`;
      // 軸の描画
      graphHtml += `<line x1="${margin}" y1="${height - margin}" x2="${width - margin}" y2="${height - margin}" stroke="black"/>`;
      graphHtml += `<line x1="${margin}" y1="${margin}" x2="${margin}" y2="${height - margin}" stroke="black"/>`;
      // 軸ラベル
      graphHtml += `<text x="${width / 2}" y="${height - 5}" text-anchor="middle" font-size="10">Index</text>`;
      graphHtml += `<text x="${margin + 5}" y="${margin - 10}" text-anchor="start" font-size="10">Value</text>`;
      // スケールの計算（yはmin/maxに基づき、xはインデックスに基づく）
      const yRange = max - min;
      const yScale = yRange === 0 ? 0 : (height - margin * 2) / yRange;
      const xStep = numbers.length > 1 ? (width - margin * 2) / (numbers.length - 1) : 0;
      // y軸目盛（5分割）+ グリッドライン
      const yTicks = 5;
      for (let t = 0; t <= yTicks; t++) {
          const v = yRange === 0 ? min : (min + (yRange * t) / yTicks);
          const yTick = yRange === 0 ? (height / 2) : (height - margin - ((v - min) * yScale));
          // グリッドライン
          graphHtml += `<line x1="${margin}" y1="${yTick}" x2="${width - margin}" y2="${yTick}" stroke="#eeeeee"/>`;
          // 目盛ラベル
          graphHtml += `<text x="${margin - 6}" y="${yTick + 3}" text-anchor="end" font-size="10">${fmt(v)}</text>`;
      }
      // x軸の端点ラベル（混雑を避けて最小限）
      graphHtml += `<text x="${margin}" y="${height - margin + 12}" text-anchor="middle" font-size="10">0</text>`;
      graphHtml += `<text x="${width - margin}" y="${height - margin + 12}" text-anchor="middle" font-size="10">${Math.max(numbers.length - 1, 0)}</text>`;
      // 値→Y座標（min/maxにクランプ）
      const toY = (v) => yRange === 0
          ? (height / 2)
          : (height - margin - ((Math.max(Math.min(v, max), min) - min) * yScale));
      // ラベル配置補助（重なり回避・枠内収まり）
      const labelBoxes = [];
      const estimateTextWidth = (text) => Math.min(240, (text?.length || 0) * 6); // font-size 10px の簡易幅推定
      const labelPadding = 8; // ラベル同士の最小距離
      const intersectsPad = (a, b, pad) => !(
          (a.x + a.w + pad) <= (b.x - pad) ||
          (b.x + b.w + pad) <= (a.x - pad) ||
          (a.y + a.h + pad) <= (b.y - pad) ||
          (b.y + b.h + pad) <= (a.y - pad)
      );
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const crossesLinePad = (box, lineY, pad) => lineY != null && lineY >= (box.y - pad) && lineY <= (box.y + box.h + pad);
      let meanYPos = null;
      let medianYPos = null;
      // 平均線（破線）
      if (showMean) {
          const meanY = toY(mean);
          const t = `mean=${fmt(mean)}`;
          const lw = estimateTextWidth(t);
          const lh = 12;
          const reserve = lw + labelPadding + 4; // ラベル領域を右側に確保
          const lineRightX = Math.max(margin + 20, (width - margin) - reserve);
          const labelX = lineRightX + labelPadding;
          // 線をラベル領域の左端までに短縮して描画
          graphHtml += `<line x1="${margin}" y1="${meanY}" x2="${lineRightX}" y2="${meanY}" stroke="red" stroke-dasharray="4 2"/>`;
          // 縦方向の衝突回避（上下にずらす）
          let labelY = meanY - 5;
          const baseBoxMean = (y) => ({ x: labelX, y: (y - lh + 2), w: lw, h: lh });
          const withinYMean = (y) => {
              const box = baseBoxMean(y);
              return box.y >= margin && (box.y + box.h) <= (height - margin);
          };
          const collidesMean = (b) => labelBoxes.some((lb) => intersectsPad(b, lb, labelPadding));
          let boxMean = baseBoxMean(labelY);
          if (collidesMean(boxMean)) {
              const stepY = lh + labelPadding;
              let placed = false;
              for (let step = 1; step <= 10 && !placed; step++) {
                  const yDown = labelY + stepY * step;
                  if (withinYMean(yDown)) {
                      const bDown = baseBoxMean(yDown);
                      if (!collidesMean(bDown)) { labelY = yDown; boxMean = bDown; placed = true; break; }
                  }
                  const yUp = labelY - stepY * step;
                  if (withinYMean(yUp)) {
                      const bUp = baseBoxMean(yUp);
                      if (!collidesMean(bUp)) { labelY = yUp; boxMean = bUp; placed = true; break; }
                  }
              }
          }
          graphHtml += `<text x="${labelX}" y="${labelY}" text-anchor="start" font-size="10" fill="red">${t}</text>`;
          meanYPos = meanY;
          labelBoxes.push(boxMean);
      }
      // 中央値線（破線）
      if (showMedian) {
          const medianY = toY(median);
          const t = `median=${fmt(median)}`;
          const lw = estimateTextWidth(t);
          const lh = 12;
          const reserve = lw + labelPadding + 4; // ラベル領域を右側に確保
          const lineRightX = Math.max(margin + 20, (width - margin) - reserve);
          const labelX = lineRightX + labelPadding;
          // 線をラベル領域の左端までに短縮して描画
          graphHtml += `<line x1="${margin}" y1="${medianY}" x2="${lineRightX}" y2="${medianY}" stroke="green" stroke-dasharray="4 2"/>`;
          // 既存ラベルと重なる場合、上下にオフセットして回避（右側固定）
          let labelY = medianY - 5;
          const baseBox = (y) => ({ x: labelX, y: (y - lh + 2), w: lw, h: lh });
          const withinY = (y) => {
              const box = baseBox(y);
              return box.y >= margin && (box.y + box.h) <= (height - margin);
          };
          let box = baseBox(labelY);
          const collides = (b) => labelBoxes.some((lb) => intersectsPad(b, lb, labelPadding));
          if (collides(box)) {
              const stepY = lh + labelPadding;
              let placed = false;
              for (let step = 1; step <= 10 && !placed; step++) {
                  const yDown = labelY + stepY * step;
                  if (withinY(yDown)) {
                      const bDown = baseBox(yDown);
                      if (!collides(bDown)) { labelY = yDown; box = bDown; placed = true; break; }
                  }
                  const yUp = labelY - stepY * step;
                  if (withinY(yUp)) {
                      const bUp = baseBox(yUp);
                      if (!collides(bUp)) { labelY = yUp; box = bUp; placed = true; break; }
                  }
              }
          }
          graphHtml += `<text x="${labelX}" y="${labelY}" text-anchor="start" font-size="10" fill="green">${t}</text>`;
          medianYPos = medianY;
          labelBoxes.push(box);
      }
      // 散布図の点を描画（データ属性で元行を保持）
      const escAttr = (s) => String(s)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      for (let i = 0; i < numbers.length; i++) {
          const x = numbers.length > 1 ? margin + i * xStep : width / 2;
          const y = height - margin - ((numbers[i] - min) * yScale);
          const cy = yRange === 0 ? height / 2 : y; // すべて同値のときは中央線上に配置
          const rawText = entries[i]?.raw ?? String(numbers[i]);
          const isOut = highlightOutliers && stdDev > 0 && Math.abs(numbers[i] - mean) > outlierK * stdDev;
          const fill = isOut ? 'tomato' : 'blue';
          graphHtml += `<circle cx="${x}" cy="${cy}" r="3" fill="${fill}" data-index="${i}" data-value="${fmt(numbers[i])}" data-raw="${escAttr(rawText)}" data-outlier="${isOut ? '1' : '0'}"></circle>`;
          if (showLabels) {
              const labelText = entries[i]?.raw ?? String(numbers[i]);
              const lw = estimateTextWidth(labelText);
              const lh = 12; // 高さ推定
              // 候補位置（右上, 右下, 左上, 左下）
              const candidates = [
                  { x: x + 8, y: cy - 8 },
                  { x: x + 8, y: cy + lh },
                  { x: x - lw - 8, y: cy - 8 },
                  { x: x - lw - 8, y: cy + lh }
              ];
              let chosen = null;
              // まずは候補から重なりなし・枠内のものを探す
              for (const c of candidates) {
                  const box = { x: c.x, y: c.y - lh + 2, w: lw, h: lh };
                  const within = box.x >= margin && (box.x + box.w) <= (width - margin) && box.y >= margin && (box.y + box.h) <= (height - margin);
                  if (!within) continue;
                  // 平均・中央値ラインと交差（最小距離未満）する場合は避ける
                  if (crossesLinePad(box, meanYPos, labelPadding) || crossesLinePad(box, medianYPos, labelPadding)) continue;
                  let collide = false;
                  for (const b of labelBoxes) {
                      if (intersectsPad(box, b, labelPadding)) { collide = true; break; }
                  }
                  if (!collide) { chosen = { x: c.x, y: c.y }; break; }
              }
              // だめなら下方向に少しずつずらして探索
              if (!chosen) {
                  for (let step = 0; step < 10 && !chosen; step++) {
                      const c = { x: x + 8, y: cy + lh + step * lh };
                      let cx = clamp(c.x, margin, width - margin - lw);
                      let cy2 = clamp(c.y, margin + lh, height - margin);
                      const box = { x: cx, y: cy2 - lh + 2, w: lw, h: lh };
                      // 平均・中央値ラインと交差（最小距離未満）する場合は避ける
                      if (crossesLinePad(box, meanYPos, labelPadding) || crossesLinePad(box, medianYPos, labelPadding)) continue;
                      let collide = false;
                      for (const b of labelBoxes) {
                          if (intersectsPad(box, b, labelPadding)) { collide = true; break; }
                      }
                      if (!collide) { chosen = { x: cx, y: cy2 }; break; }
                  }
              }
              // それでも見つからなければ、枠内にクランプした右上に配置（重なりは許容）
              if (!chosen) {
                  const cx = clamp(x + 8, margin, width - margin - lw);
                  const cy2 = clamp(cy - 8, margin + lh, height - margin);
                  chosen = { x: cx, y: cy2 };
              }
              // ラベル描画とボックス登録
              graphHtml += `<text x="${chosen.x}" y="${chosen.y}" font-size="10" fill="#333" pointer-events="none">${escAttr(labelText)}</text>`;
              labelBoxes.push({ x: chosen.x, y: chosen.y - lh + 2, w: lw, h: lh });
          }
      }
      graphHtml += '</svg>';
      const container = document.getElementById("output-graph");
      container.style.position = 'relative';
      container.innerHTML = graphHtml;
      // カスタムツールチップの作成/取得
      let tooltip = container.querySelector('.svg-tooltip');
      if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.className = 'svg-tooltip';
          const style = tooltip.style;
          style.position = 'absolute';
          style.pointerEvents = 'none';
          style.background = '#fff';
          style.border = '1px solid #ccc';
          style.padding = '4px 6px';
          style.fontSize = '12px';
          style.borderRadius = '4px';
          style.boxShadow = '0 1px 4px rgba(0,0,0,0.2)';
          style.display = 'none';
          style.whiteSpace = 'pre';
          container.appendChild(tooltip);
      }
      const svg = container.querySelector('svg');
      const circles = svg ? svg.querySelectorAll('circle') : [];
      circles.forEach((circle) => {
          const show = (e) => {
              const raw = circle.getAttribute('data-raw') || '';
              const val = circle.getAttribute('data-value') || '';
              tooltip.textContent = `list: ${raw}\nvalue: ${val}`;
              tooltip.style.display = 'block';
              const rect = container.getBoundingClientRect();
              const x = e.clientX - rect.left + 10;
              const y = e.clientY - rect.top + 10;
              tooltip.style.left = `${x}px`;
              tooltip.style.top = `${y}px`;
          };
          const hide = () => { tooltip.style.display = 'none'; };
          circle.addEventListener('mouseenter', show);
          circle.addEventListener('mousemove', show);
          circle.addEventListener('mouseleave', hide);
      });
  }
}
</script>

<script>
// 便利機能の初期化（コピー、ダウンロード、サンプル投入、オプション変更）
document.addEventListener('DOMContentLoaded', () => {
    const copyBtn = document.getElementById('btn-copy');
    if (copyBtn) copyBtn.addEventListener('click', async () => {
        const text = document.getElementById('output').innerText;
        try {
            await navigator.clipboard.writeText(text);
        } catch (err) {
            const tmp = document.createElement('textarea');
            tmp.value = text;
            document.body.appendChild(tmp);
            tmp.select();
            document.execCommand('copy');
            document.body.removeChild(tmp);
        }
    });
    const dlPngBtn = document.getElementById('btn-download-png');
    if (dlPngBtn) dlPngBtn.addEventListener('click', () => {
        const svg = document.querySelector('#output-graph svg');
        if (!svg) return;
        const serializer = new XMLSerializer();
        const source = serializer.serializeToString(svg);
        const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = () => {
            const width = parseInt(svg.getAttribute('width')) || svg.clientWidth || 500;
            const height = parseInt(svg.getAttribute('height')) || svg.clientHeight || 300;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
            ctx.drawImage(img, 0, 0);
            URL.revokeObjectURL(url);
            const pngUrl = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = pngUrl;
            a.download = 'graph.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
        img.src = url;
    });
    // 入力クリア機能は削除
    // 数値のみコピー
    const copyNumsBtn = document.getElementById('btn-copy-numbers');
    if (copyNumsBtn) copyNumsBtn.addEventListener('click', async () => {
        const ta = document.getElementById('list');
        const lines = ta.value.split('\n');
        const cleaned = [];
        for (const line of lines) {
            const t = line.trim();
            if (!t) continue;
            const m = t.replace(/[^0-9.\-]/g, '');
            const n = Number(m);
            if (!isNaN(n)) cleaned.push(n);
        }
        const decEl = document.getElementById('opt-decimals');
        const dec = decEl ? Math.max(0, Math.min(6, parseInt(decEl.value) || 0)) : 2;
        const text = cleaned.map(v => Number(v).toFixed(dec)).join('\n');
        try {
            await navigator.clipboard.writeText(text);
        } catch (err) {
            const tmp = document.createElement('textarea');
            tmp.value = text;
            document.body.appendChild(tmp);
            tmp.select();
            document.execCommand('copy');
            document.body.removeChild(tmp);
        }
    });
    // URLをコピー（現在の入力とオプションをハッシュに保存）
    const copyUrlBtn = document.getElementById('btn-copy-url');
    if (copyUrlBtn) copyUrlBtn.addEventListener('click', async () => {
        const params = new URLSearchParams();
        params.set('data', document.getElementById('list').value);
        params.set('mean', document.getElementById('opt-show-mean')?.checked ? '1' : '0');
        params.set('median', document.getElementById('opt-show-median')?.checked ? '1' : '0');
        params.set('dec', document.getElementById('opt-decimals')?.value || '2');
        params.set('out', document.getElementById('opt-highlight-outliers')?.checked ? '1' : '0');
        params.set('k', document.getElementById('opt-outlier-k')?.value || '2');
        const url = `${location.origin}${location.pathname}#${params.toString()}`;
        try {
            await navigator.clipboard.writeText(url);
        } catch (err) {
            const tmp = document.createElement('textarea');
            tmp.value = url;
            document.body.appendChild(tmp);
            tmp.select();
            document.execCommand('copy');
            document.body.removeChild(tmp);
        }
    });
    ['opt-show-mean','opt-show-median','opt-decimals','opt-highlight-outliers','opt-outlier-k','opt-show-labels'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', run);
    });
    // ハッシュから初期値を読み込み
    if (location.hash && location.hash.length > 1) {
        const params = new URLSearchParams(location.hash.slice(1));
        const data = params.get('data');
        if (data !== null) {
            const ta = document.getElementById('list');
            ta.value = data;
        }
        const setChk = (id, key) => {
            const v = params.get(key);
            if (v !== null) {
                const el = document.getElementById(id);
                if (el) el.checked = v === '1';
            }
        };
        const setNum = (id, key) => {
            const v = params.get(key);
            if (v !== null) {
                const el = document.getElementById(id);
                if (el) el.value = v;
            }
        };
        setChk('opt-show-mean', 'mean');
        setChk('opt-show-median', 'median');
        setChk('opt-highlight-outliers', 'out');
        setNum('opt-decimals', 'dec');
        setNum('opt-outlier-k', 'k');
    }
    // 初期描画
    run();
});
</script>]]></content><author><name>makietan</name></author><category term="tech" /><summary type="html"><![CDATA[概要 このプログラムは、与えられた数値のリストから平均値、中央値、最頻値を計算します。数値は改行で区切られた形式で入力されます。 使用方法 下のテキストエリアに数値を改行で区切って入力します。 ページを読み込むと、平均値、中央値、最頻値が計算され、表示されます。 テキストエリア オプション 平均線を表示 中央値線を表示 小数桁: 結果をコピー グラフを保存(PNG) 外れ値をハイライト k(σ): ラベル表示 数値をコピー URLをコピー 結果表示]]></summary></entry></feed>