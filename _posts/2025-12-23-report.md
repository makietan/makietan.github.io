---
layout: post
title:  "平均値、中央値、最頻値、標準偏差を求めるプログラム"
categories: tech
date: "2025-12-23 00:00:00"
---

## 概要
このプログラムは、与えられた数値のリストから平均値、中央値、最頻値を計算します。数値は改行で区切られた形式で入力されます。
## 使用方法
1. 下のテキストエリアに数値を改行で区切って入力します。
2. ページを読み込むと、平均値、中央値、最頻値が計算され、表示されます。
## テキストエリア
<textarea rows="20" cols="80" id="list" oninput="run()"></textarea>
## オプション
<div id="controls" style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:8px 0;">
    <label><input type="checkbox" id="opt-show-mean" checked> 平均線を表示</label>
    <label><input type="checkbox" id="opt-show-median" checked> 中央値線を表示</label>
    <label>小数桁: <input type="number" id="opt-decimals" value="2" min="0" max="6" style="width:60px"></label>
    <button id="btn-copy" type="button">結果をコピー</button>
    <button id="btn-download-png" type="button">グラフを保存(PNG)</button>
    <label><input type="checkbox" id="opt-highlight-outliers"> 外れ値をハイライト</label>
    <label>k(σ): <input type="number" id="opt-outlier-k" value="2" min="0" max="10" step="0.5" style="width:60px"></label>
    <label><input type="checkbox" id="opt-show-labels"> ラベル表示</label>
    <button id="btn-copy-numbers" type="button">数値をコピー</button>
    <button id="btn-copy-url" type="button">URLをコピー</button>
    <style>
        #controls button { padding: 4px 8px; }
        #controls label { user-select: none; }
    </style>
</div>
## 結果表示
<div id="output"></div>
<br>
<div id="output-graph"></div>
<script>
function run() {
    const list = document.getElementById("list").value.split("\n");
    // 元行テキストと数値の対応を保持
    const entries = [];
    for (const line of list) {
            const t = line.trim();
            if (t === "") continue;
            const cleaned = t.replace(/[^0-9.\-]/g, '');
            const n = Number(cleaned);
            if (!isNaN(n)) {
                    entries.push({ value: n, raw: t });
            }
    }
    const numbers = entries.map(e => e.value);
  if (numbers.length === 0) {
      document.getElementById("output").textContent = "有効な数値がありません。";
  } else {
      // 表示オプションとフォーマッタ
      const showMean = document.getElementById('opt-show-mean')?.checked ?? true;
      const showMedian = document.getElementById('opt-show-median')?.checked ?? true;
      const decimalsInput = document.getElementById('opt-decimals');
      const decimals = decimalsInput ? Math.max(0, Math.min(6, parseInt(decimalsInput.value) || 0)) : 2;
      const fmt = (v) => (Number.isFinite(v) ? Number(v).toFixed(decimals) : String(v));
      const highlightOutliers = document.getElementById('opt-highlight-outliers')?.checked ?? false;
      const outlierKInput = document.getElementById('opt-outlier-k');
      const outlierK = outlierKInput ? Math.max(0, Math.min(10, parseFloat(outlierKInput.value) || 0)) : 0;
      const showLabels = document.getElementById('opt-show-labels')?.checked ?? false;
      // 平均値の計算
      const sum = numbers.reduce((a, b) => a + b, 0);
      const mean = sum / numbers.length;
      // 中央値の計算
      const sorted = [...numbers].sort((a, b) => a - b);
      let median;
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
          median = (sorted[mid - 1] + sorted[mid]) / 2;
      } else {
          median = sorted[mid];
      }
      // 最頻値の計算
      const frequency = {};
      let maxFreq = 0;
      let mode;
      for (const num of numbers) {
          frequency[num] = (frequency[num] || 0) + 1;
          if (frequency[num] > maxFreq) {
              maxFreq = frequency[num];
              mode = num;
          }
      }
      // 分散の計算
      const variance = numbers.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / numbers.length;
      // 標準偏差の計算
      const stdDev = Math.sqrt(variance);
      // 最小値と最大値の計算
      const min = Math.min(...numbers);
      const max = Math.max(...numbers);
      // 範囲の計算
      const range = max - min;
      // 歪度の計算
      const skewness = numbers.reduce((a, b) => a + Math.pow((b - mean) / stdDev, 3), 0) / numbers.length;
      // 尖度の計算
      const kurtosis = numbers.reduce((a, b) => a + Math.pow((b - mean) / stdDev, 4), 0) / numbers.length - 3;
      // 結果の表示
      document.getElementById("output").innerText = [
          `平均値: ${fmt(mean)}`,
          `中央値: ${fmt(median)}`,
          `最頻値: ${fmt(mode)}`,
          `分散: ${fmt(variance)}`,
          `標準偏差: ${fmt(stdDev)}`,
          `最小値: ${fmt(min)}`,
          `最大値: ${fmt(max)}`,
          `範囲: ${fmt(range)}`,
          `歪度: ${fmt(skewness)}`,
          `尖度: ${fmt(kurtosis)}`
      ].join("\n");
      // ヒストグラム計算は不要になったため削除（散布図のみ描画）
      // numbers を使って 散布図を描画する（x=インデックス, y=値）
            const containerEl = document.getElementById("output-graph");
            const containerWidth = containerEl ? containerEl.clientWidth : 0;
            const width = Math.max(360, containerWidth || 600);
            const height = Math.round(width * 0.6);
            const margin = 50;
            let graphHtml = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="border:1px solid black;width:100%;height:auto">`;
      // 軸の描画
      graphHtml += `<line x1="${margin}" y1="${height - margin}" x2="${width - margin}" y2="${height - margin}" stroke="black"/>`;
      graphHtml += `<line x1="${margin}" y1="${margin}" x2="${margin}" y2="${height - margin}" stroke="black"/>`;
      // 軸ラベル
      graphHtml += `<text x="${width / 2}" y="${height - 5}" text-anchor="middle" font-size="10">Index</text>`;
      graphHtml += `<text x="${margin + 5}" y="${margin - 10}" text-anchor="start" font-size="10">Value</text>`;
      // スケールの計算（yはmin/maxに基づき、xはインデックスに基づく）
      const yRange = max - min;
      const yScale = yRange === 0 ? 0 : (height - margin * 2) / yRange;
      const xStep = numbers.length > 1 ? (width - margin * 2) / (numbers.length - 1) : 0;
      // y軸目盛（5分割）+ グリッドライン
      const yTicks = 5;
      for (let t = 0; t <= yTicks; t++) {
          const v = yRange === 0 ? min : (min + (yRange * t) / yTicks);
          const yTick = yRange === 0 ? (height / 2) : (height - margin - ((v - min) * yScale));
          // グリッドライン
          graphHtml += `<line x1="${margin}" y1="${yTick}" x2="${width - margin}" y2="${yTick}" stroke="#eeeeee"/>`;
          // 目盛ラベル
          graphHtml += `<text x="${margin - 6}" y="${yTick + 3}" text-anchor="end" font-size="10">${fmt(v)}</text>`;
      }
      // x軸の端点ラベル（混雑を避けて最小限）
      graphHtml += `<text x="${margin}" y="${height - margin + 12}" text-anchor="middle" font-size="10">0</text>`;
      graphHtml += `<text x="${width - margin}" y="${height - margin + 12}" text-anchor="middle" font-size="10">${Math.max(numbers.length - 1, 0)}</text>`;
      // 値→Y座標（min/maxにクランプ）
      const toY = (v) => yRange === 0
          ? (height / 2)
          : (height - margin - ((Math.max(Math.min(v, max), min) - min) * yScale));
      // ラベル配置補助（重なり回避・枠内収まり）
      const labelBoxes = [];
      const estimateTextWidth = (text) => Math.min(240, (text?.length || 0) * 6); // font-size 10px の簡易幅推定
      const labelPadding = 8; // ラベル同士の最小距離
      const intersectsPad = (a, b, pad) => !(
          (a.x + a.w + pad) <= (b.x - pad) ||
          (b.x + b.w + pad) <= (a.x - pad) ||
          (a.y + a.h + pad) <= (b.y - pad) ||
          (b.y + b.h + pad) <= (a.y - pad)
      );
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const crossesLinePad = (box, lineY, pad) => lineY != null && lineY >= (box.y - pad) && lineY <= (box.y + box.h + pad);
      let meanYPos = null;
      let medianYPos = null;
      // 平均線（破線）
      if (showMean) {
          const meanY = toY(mean);
          graphHtml += `<line x1="${margin}" y1="${meanY}" x2="${width - margin}" y2="${meanY}" stroke="red" stroke-dasharray="4 2"/>`;
          graphHtml += `<text x="${width - margin}" y="${meanY - 5}" text-anchor="end" font-size="10" fill="red">mean=${fmt(mean)}</text>`;
          meanYPos = meanY;
          // 平均ラベルのボックスを登録
          const t = `mean=${fmt(mean)}`;
          const lw = estimateTextWidth(t);
          const lh = 12;
          const bx = Math.max(margin, (width - margin) - lw);
          const by = (meanY - 5) - lh + 2;
          labelBoxes.push({ x: bx, y: by, w: lw, h: lh });
      }
      // 中央値線（破線）
      if (showMedian) {
          const medianY = toY(median);
          graphHtml += `<line x1="${margin}" y1="${medianY}" x2="${width - margin}" y2="${medianY}" stroke="green" stroke-dasharray="4 2"/>`;
          const t = `median=${fmt(median)}`;
          const lw = estimateTextWidth(t);
          const lh = 12;
          const xRight = width - margin;
          let labelY = medianY - 5;
          const baseBox = (y) => ({ x: Math.max(margin, xRight - lw), y: (y - lh + 2), w: lw, h: lh });
          // 既存ラベル（例: meanラベル）と重なる場合、上下にオフセットして回避（右側固定）
          const stepY = lh + labelPadding;
          const withinY = (y) => {
              const box = baseBox(y);
              return box.y >= margin && (box.y + box.h) <= (height - margin);
          };
          let box = baseBox(labelY);
          const collides = (b) => labelBoxes.some((lb) => intersectsPad(b, lb, labelPadding));
          if (collides(box)) {
              let placed = false;
              for (let step = 1; step <= 10 && !placed; step++) {
                  const yDown = labelY + stepY * step;
                  if (withinY(yDown)) {
                      const bDown = baseBox(yDown);
                      if (!collides(bDown)) { labelY = yDown; box = bDown; placed = true; break; }
                  }
                  const yUp = labelY - stepY * step;
                  if (withinY(yUp)) {
                      const bUp = baseBox(yUp);
                      if (!collides(bUp)) { labelY = yUp; box = bUp; placed = true; break; }
                  }
              }
          }
          graphHtml += `<text x="${xRight}" y="${labelY}" text-anchor="end" font-size="10" fill="green">${t}</text>`;
          medianYPos = medianY;
          labelBoxes.push(box);
      }
      // 散布図の点を描画（データ属性で元行を保持）
      const escAttr = (s) => String(s)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      for (let i = 0; i < numbers.length; i++) {
          const x = numbers.length > 1 ? margin + i * xStep : width / 2;
          const y = height - margin - ((numbers[i] - min) * yScale);
          const cy = yRange === 0 ? height / 2 : y; // すべて同値のときは中央線上に配置
          const rawText = entries[i]?.raw ?? String(numbers[i]);
          const isOut = highlightOutliers && stdDev > 0 && Math.abs(numbers[i] - mean) > outlierK * stdDev;
          const fill = isOut ? 'tomato' : 'blue';
          graphHtml += `<circle cx="${x}" cy="${cy}" r="3" fill="${fill}" data-index="${i}" data-value="${fmt(numbers[i])}" data-raw="${escAttr(rawText)}" data-outlier="${isOut ? '1' : '0'}"></circle>`;
          if (showLabels) {
              const labelText = entries[i]?.raw ?? String(numbers[i]);
              const lw = estimateTextWidth(labelText);
              const lh = 12; // 高さ推定
              // 候補位置（右上, 右下, 左上, 左下）
              const candidates = [
                  { x: x + 8, y: cy - 8 },
                  { x: x + 8, y: cy + lh },
                  { x: x - lw - 8, y: cy - 8 },
                  { x: x - lw - 8, y: cy + lh }
              ];
              let chosen = null;
              // まずは候補から重なりなし・枠内のものを探す
              for (const c of candidates) {
                  const box = { x: c.x, y: c.y - lh + 2, w: lw, h: lh };
                  const within = box.x >= margin && (box.x + box.w) <= (width - margin) && box.y >= margin && (box.y + box.h) <= (height - margin);
                  if (!within) continue;
                  // 平均・中央値ラインと交差（最小距離未満）する場合は避ける
                  if (crossesLinePad(box, meanYPos, labelPadding) || crossesLinePad(box, medianYPos, labelPadding)) continue;
                  let collide = false;
                  for (const b of labelBoxes) {
                      if (intersectsPad(box, b, labelPadding)) { collide = true; break; }
                  }
                  if (!collide) { chosen = { x: c.x, y: c.y }; break; }
              }
              // だめなら下方向に少しずつずらして探索
              if (!chosen) {
                  for (let step = 0; step < 10 && !chosen; step++) {
                      const c = { x: x + 8, y: cy + lh + step * lh };
                      let cx = clamp(c.x, margin, width - margin - lw);
                      let cy2 = clamp(c.y, margin + lh, height - margin);
                      const box = { x: cx, y: cy2 - lh + 2, w: lw, h: lh };
                      // 平均・中央値ラインと交差（最小距離未満）する場合は避ける
                      if (crossesLinePad(box, meanYPos, labelPadding) || crossesLinePad(box, medianYPos, labelPadding)) continue;
                      let collide = false;
                      for (const b of labelBoxes) {
                          if (intersectsPad(box, b, labelPadding)) { collide = true; break; }
                      }
                      if (!collide) { chosen = { x: cx, y: cy2 }; break; }
                  }
              }
              // それでも見つからなければ、枠内にクランプした右上に配置（重なりは許容）
              if (!chosen) {
                  const cx = clamp(x + 8, margin, width - margin - lw);
                  const cy2 = clamp(cy - 8, margin + lh, height - margin);
                  chosen = { x: cx, y: cy2 };
              }
              // ラベル描画とボックス登録
              graphHtml += `<text x="${chosen.x}" y="${chosen.y}" font-size="10" fill="#333" pointer-events="none">${escAttr(labelText)}</text>`;
              labelBoxes.push({ x: chosen.x, y: chosen.y - lh + 2, w: lw, h: lh });
          }
      }
      graphHtml += '</svg>';
      const container = document.getElementById("output-graph");
      container.style.position = 'relative';
      container.innerHTML = graphHtml;
      // カスタムツールチップの作成/取得
      let tooltip = container.querySelector('.svg-tooltip');
      if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.className = 'svg-tooltip';
          const style = tooltip.style;
          style.position = 'absolute';
          style.pointerEvents = 'none';
          style.background = '#fff';
          style.border = '1px solid #ccc';
          style.padding = '4px 6px';
          style.fontSize = '12px';
          style.borderRadius = '4px';
          style.boxShadow = '0 1px 4px rgba(0,0,0,0.2)';
          style.display = 'none';
          style.whiteSpace = 'pre';
          container.appendChild(tooltip);
      }
      const svg = container.querySelector('svg');
      const circles = svg ? svg.querySelectorAll('circle') : [];
      circles.forEach((circle) => {
          const show = (e) => {
              const raw = circle.getAttribute('data-raw') || '';
              const val = circle.getAttribute('data-value') || '';
              tooltip.textContent = `list: ${raw}\nvalue: ${val}`;
              tooltip.style.display = 'block';
              const rect = container.getBoundingClientRect();
              const x = e.clientX - rect.left + 10;
              const y = e.clientY - rect.top + 10;
              tooltip.style.left = `${x}px`;
              tooltip.style.top = `${y}px`;
          };
          const hide = () => { tooltip.style.display = 'none'; };
          circle.addEventListener('mouseenter', show);
          circle.addEventListener('mousemove', show);
          circle.addEventListener('mouseleave', hide);
      });
  }
}
</script>
<script>
// 便利機能の初期化（コピー、ダウンロード、サンプル投入、オプション変更）
document.addEventListener('DOMContentLoaded', () => {
    const copyBtn = document.getElementById('btn-copy');
    if (copyBtn) copyBtn.addEventListener('click', async () => {
        const text = document.getElementById('output').innerText;
        try {
            await navigator.clipboard.writeText(text);
        } catch (err) {
            const tmp = document.createElement('textarea');
            tmp.value = text;
            document.body.appendChild(tmp);
            tmp.select();
            document.execCommand('copy');
            document.body.removeChild(tmp);
        }
    });
    const dlPngBtn = document.getElementById('btn-download-png');
    if (dlPngBtn) dlPngBtn.addEventListener('click', () => {
        const svg = document.querySelector('#output-graph svg');
        if (!svg) return;
        const serializer = new XMLSerializer();
        const source = serializer.serializeToString(svg);
        const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = () => {
            const width = parseInt(svg.getAttribute('width')) || svg.clientWidth || 500;
            const height = parseInt(svg.getAttribute('height')) || svg.clientHeight || 300;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
            ctx.drawImage(img, 0, 0);
            URL.revokeObjectURL(url);
            const pngUrl = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = pngUrl;
            a.download = 'graph.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
        img.src = url;
    });
    // 入力クリア機能は削除
    // 数値のみコピー
    const copyNumsBtn = document.getElementById('btn-copy-numbers');
    if (copyNumsBtn) copyNumsBtn.addEventListener('click', async () => {
        const ta = document.getElementById('list');
        const lines = ta.value.split('\n');
        const cleaned = [];
        for (const line of lines) {
            const t = line.trim();
            if (!t) continue;
            const m = t.replace(/[^0-9.\-]/g, '');
            const n = Number(m);
            if (!isNaN(n)) cleaned.push(n);
        }
        const decEl = document.getElementById('opt-decimals');
        const dec = decEl ? Math.max(0, Math.min(6, parseInt(decEl.value) || 0)) : 2;
        const text = cleaned.map(v => Number(v).toFixed(dec)).join('\n');
        try {
            await navigator.clipboard.writeText(text);
        } catch (err) {
            const tmp = document.createElement('textarea');
            tmp.value = text;
            document.body.appendChild(tmp);
            tmp.select();
            document.execCommand('copy');
            document.body.removeChild(tmp);
        }
    });
    // URLをコピー（現在の入力とオプションをハッシュに保存）
    const copyUrlBtn = document.getElementById('btn-copy-url');
    if (copyUrlBtn) copyUrlBtn.addEventListener('click', async () => {
        const params = new URLSearchParams();
        params.set('data', document.getElementById('list').value);
        params.set('mean', document.getElementById('opt-show-mean')?.checked ? '1' : '0');
        params.set('median', document.getElementById('opt-show-median')?.checked ? '1' : '0');
        params.set('dec', document.getElementById('opt-decimals')?.value || '2');
        params.set('out', document.getElementById('opt-highlight-outliers')?.checked ? '1' : '0');
        params.set('k', document.getElementById('opt-outlier-k')?.value || '2');
        const url = `${location.origin}${location.pathname}#${params.toString()}`;
        try {
            await navigator.clipboard.writeText(url);
        } catch (err) {
            const tmp = document.createElement('textarea');
            tmp.value = url;
            document.body.appendChild(tmp);
            tmp.select();
            document.execCommand('copy');
            document.body.removeChild(tmp);
        }
    });
    ['opt-show-mean','opt-show-median','opt-decimals','opt-highlight-outliers','opt-outlier-k','opt-show-labels'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', run);
    });
    // ハッシュから初期値を読み込み
    if (location.hash && location.hash.length > 1) {
        const params = new URLSearchParams(location.hash.slice(1));
        const data = params.get('data');
        if (data !== null) {
            const ta = document.getElementById('list');
            ta.value = data;
        }
        const setChk = (id, key) => {
            const v = params.get(key);
            if (v !== null) {
                const el = document.getElementById(id);
                if (el) el.checked = v === '1';
            }
        };
        const setNum = (id, key) => {
            const v = params.get(key);
            if (v !== null) {
                const el = document.getElementById(id);
                if (el) el.value = v;
            }
        };
        setChk('opt-show-mean', 'mean');
        setChk('opt-show-median', 'median');
        setChk('opt-highlight-outliers', 'out');
        setNum('opt-decimals', 'dec');
        setNum('opt-outlier-k', 'k');
    }
    // 初期描画
    run();
});
</script>
